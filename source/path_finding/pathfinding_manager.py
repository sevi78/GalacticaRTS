import math

import pygame

from source.configuration.game_config import config
from source.draw.arrow import draw_arrows_on_line_from_start_to_end
from source.gui.event_text import event_text
from source.handlers.pan_zoom_handler import pan_zoom_handler
from source.handlers.pan_zoom_sprite_handler import sprite_groups
from source.path_finding.a_star_node_path_finding import Node, astar


class PathFindingManager:
    """
    Summary

    The PathFindingManager class is responsible for managing the pathfinding functionality in a game. It uses the
    A* algorithm to find the shortest path between two nodes in a graph. The class keeps track of the start and
    end nodes, the maximum distance between nodes, and the path generated by the algorithm. It also provides methods to
    update the nodes, set the start and end nodes, generate the path, and move along the path.

    Example Usage
    # Create an instance of the PathFindingManager class
    path_manager = PathFindingManager(parent)

    # Set the start and end nodes
    path_manager.set_start_node(start_node)
    path_manager.set_end_node(end_node)

    # Set the maximum distance between nodes
    path_manager.set_max_distance(max_distance)

    # Generate the path
    path_manager.generate_path(start_node, end_node, max_distance)

    # Move to the next node in the path
    path_manager.move_to_next_node()

    # Follow the path
    path_manager.follow_path(hit_object)

    # Draw the path
    path_manager.draw_path()

    # Update the path manager
    path_manager.update()
    Code Analysis
    Main functionalities
    Manages the pathfinding functionality in a game
    Uses the A* algorithm to find the shortest path between two nodes in a graph
    Keeps track of the start and end nodes, the maximum distance between nodes, and the path generated by the algorithm
    Provides methods to update the nodes, set the start and end nodes, generate the path, move along the path, follow
    the path, and draw the path

    Methods:

    __init__(self, parent): Initializes the PathFindingManager instance with a parent object

    reset(self):    Resets the PathFindingManager instance by clearing the nodes, path, start and end nodes,
                    and maximum distance

    update_nodes(self): Updates the nodes in the pathfinding manager by getting valid nodes from sprite groups and
                        updating their positions

    set_start_node(self, node): Sets the start node for pathfinding

    set_end_node(self, node): Sets the end node for pathfinding

    set_max_distance(self, distance): Sets the maximum distance between nodes for pathfinding

    generate_path(self, start_node, end_node, max_distance): Generates the path using the A* algorithm

    move_to_next_node(self): Moves to the next node in the path

    follow_path(self, hit_object):  Sets the following_path flag based on whether there is a hit object and the path is
                                    not empty

    draw_path(self): Draws the path on the screen

    update(self):   Updates the pathfinding manager by updating the nodes, generating the path, drawing the path,
                    and handling collisions

    Fields:

    parent: The parent object that the PathFindingManager instance belongs to
    nodes: The list of nodes used for pathfinding
    path: The list of nodes representing the shortest path
    start_node: The starting node for pathfinding
    end_node: The ending node for pathfinding
    max_distance: The maximum distance between nodes for pathfinding
    """

    def __init__(self, parent):
        self.parent = parent
        self.nodes = None
        self.path = None
        self.start_node = self.parent.node
        self.end_node = None
        self.max_distance = None
        self.update_nodes()

    def __repr__(self):
        return (f"PathFindingManager:\n"
                f"self.start_node:{self.start_node}\n"
                f"self.end_node:{self.end_node}\n"
                f"max_distance: {self.max_distance}\n"
                f"path:  {self.path}\n ")

    def reset(self):
        """
        The reset method in the PathFindingManager class is responsible for resetting the pathfinding manager by
        clearing the nodes, path, start and end nodes, and maximum distance.
        It also sets the parents following_path flag to False.
        """
        self.nodes = None
        self.path = None
        self.start_node = self.parent.node
        self.end_node = None
        self.max_distance = None

        self.parent.following_path = False

    def update_nodes(self) -> None:
        """
        sets the valid nodes to the pathfinding manager used to generate the path and
        updates the positions of the nodes
        """

        # get valid nodes
        self.nodes = ([i.node for i in sprite_groups.planets.sprites()] +
                      [i.node for i in sprite_groups.ships.sprites()])

        # update the nodes
        [i.update(i.owner.world_x, i.owner.world_y) for i in self.nodes]

    def set_start_node(self, node: Node) -> None:
        """sets the start node"""
        self.start_node = node

    def set_end_node(self, node: Node) -> None:
        """ sets the end node """
        self.end_node = node

    def set_max_distance(self, distance: float) -> None:
        """ sets the max distance to the pathfinding manager used to generate the path """
        self.max_distance = distance

    def generate_path(self, start_node: Node, end_node: Node, max_distance: float) -> None:
        """ generates the path using a* algorithm:
            sets star and end nodes
            generates the path
        """
        self.set_start_node(start_node)
        self.set_end_node(end_node)
        self.set_max_distance(max_distance)

        if self.start_node and self.end_node:
            self.path = astar(self.start_node, self.end_node, self.nodes, self.max_distance)

    def next_node_inside_max_distance(self, node1_pos: tuple, node2_pos: tuple, max_distance: float) -> bool:
        dist = math.dist(node1_pos, node2_pos)
        if max_distance > dist:
            return True
        return False

    def move_to_next_node(self):
        """
        The move_to_next_node method is responsible for moving to the next node in the path. It updates the orbit_object
        variable, pops the first node from the path, sets the parent's moving flag to True, and sets the parent's target
        to the next node in the path. If there are no more nodes in the path, it calls the reach_target method on the
        parent object with the desired orbit radius.
        """
        # reset orbit object, because we only want to orbit if target is reached
        orbit_object = None

        # check if it has a path already
        if self.path:
            # if any nodes left
            if len(self.path) > 1:
                # check if node is reachable
                if self.next_node_inside_max_distance(
                        self.path[0].get_position(), self.path[1].get_position(), self.parent.get_max_travel_range()):
                    # if it can reach its next node, then set new target and move on

                    self.path.pop(0)
                    self.parent.moving = True

                else:
                    # if next node not reachable, set reloader and orbit around the planet
                    event_text.set_text(f"{self.parent} has not enough energy to travel further!", obj=self.parent, sender=self.parent.owner)
                    self.parent.set_energy_reloader(self.path[0].owner)
                    orbit_object = self.path[0].owner

                    # generat new path
                    self.generate_path(self.parent.node, self.path[-1], self.parent.get_max_travel_range())

        # if still has a path
        if self.path:
            #  and any nodes left
            if not self.path[0].owner == self.parent.target:
                self.parent.target = self.path[0].owner
            else:
                # set orbit object and reset path
                orbit_object = self.path[0].owner
                self.reset()

        # if has an orbit object, orbit around and reach target
        if orbit_object:
            self.parent.reach_target(self.parent.desired_orbit_radius)

    def follow_path(self, hit_object):
        """
        The follow_path method in the PathFindingManager class is responsible for determining whether to follow a path
        or reset it based on the presence of a hit object. It updates the following_path flag of the parent object
        accordingly.

        Flow:

        If there is no hit object and the path exists, the reset method is called to reset the path.
        If the path exists, the following_path flag of the parent object is set to True.
        If the path does not exist, the following_path flag of the parent object is set to False.
        """
        if not hit_object and self.path:
            self.reset()

        if self.path:
            self.parent.following_path = True
        else:
            self.parent.following_path = False

    def draw_path(self) -> None:
        """ draws the path """
        if self.path:
            for i in range(len(self.path) - 1):
                # get nodes to draw
                current_node = self.path[i]
                next_node = self.path[i + 1]

                # get positions
                start_pos = pan_zoom_handler.world_2_screen(current_node.x, current_node.y)
                end_pos = pan_zoom_handler.world_2_screen(next_node.x, next_node.y)

                # set color: green if target can be reached, else red
                color = pygame.color.THECOLORS["green"]
                travel_range = self.parent.get_max_travel_range()
                if not self.next_node_inside_max_distance(current_node.get_position(), next_node.get_position(), travel_range):
                    color = pygame.color.THECOLORS["red"]

                # draw the arrows
                draw_arrows_on_line_from_start_to_end(
                        surf=config.app.win,
                        color=color,
                        start_pos=start_pos,
                        end_pos=end_pos,
                        width=1,
                        dash_length=30,
                        arrow_size=(0, 6),
                        )

    def update(self):
        """
        The update method in the PathFindingManager class is responsible for updating the pathfinding manager. It calls
        the update_nodes method to update the positions of the nodes. If the parent object is a ship, it checks for a
        hit object (either a planet or another ship) using the get_hit_object method from the sprite_groups object.
        If a hit object is found and the ship is not already following a path, it generates a new path from the ship's
        current position to the hit object's position using the generate_path method. Finally, it calls the draw_path
        method to draw the path on the screen.

        Flow:

        Call the update_nodes method to update the positions of the nodes.
        Check if the parent object is a ship.
        If the parent object is a ship, call the get_hit_object method from the sprite_groups object to check for a hit object.
        If a hit object is found and the ship is not already following a path, call the generate_path method to generate a new path from the ship's current position to the hit object's position.
        Call the draw_path method to draw the path on the screen.

        """
        self.update_nodes()
        if self.parent == config.app.ship:
            hit_object = sprite_groups.get_hit_object(lists=["planets", "ships"])
            if hit_object:
                if not self.parent.following_path:
                    self.generate_path(self.start_node, hit_object.node, self.parent.get_max_travel_range())
                    self.draw_path()

            # draw path
            self.draw_path()
